# 前置知识:

# 同步互斥的设计与实现
互斥是指某一个资源同时只允许一个进程对其进行访问，具有唯一性和排它性，但互斥不用限制进程对资源的访问顺序，即访问可以是无序的。同步是指在进程间的执行必须严格按照规定某种先后次序来运行，即访问是有序的，这种先后次序取决于要系统完成的任务需求。在进程写资源情况下，进程间要求满足互斥条件。在进程读资源的情况下，可允许多个进程同时访问资源。 
# 同步互斥的底层支撑
由于有处理器调度的存在，且进程在访问某类资源暂时无法满足的情况下，进程会进入等待状态。这导致了多进程执行时序的不确定性和潜在执行结果的不确定性。为了确保执行结果的正确性，本实验需要设计更加完善的进程等待和互斥的底层支撑机制，确保能正确提供基于信号量的条件变量的同步互斥机制。
根据操作系统原理的知识，我们知道如果没有在硬件级保证读内存-修改值-写回内存的原子性，我们只能通过复杂的软件来实现同步互斥操作。但由于有定时器，屏蔽/使能中断，等待队列wait_queue支持test_andr_set_bit等原子操作操作机器指令的存在，使得我们在进程瞪大，同步互斥得到极大的简化。
# 定时器
在传统的操作系统中，定时器是其中一个基础而重要的功能，它提供了基于时间事件调度机制，在ucore中，时钟中断给操作系统提供了有一定间隔的时间事件，操作系统将其作为基本的调度和计时单位，
我们记两次时间中断之间的时间间隔为一个时间片,timeer splice).
基于此时间单位，操作系统得以向上提供基于时间点的事件，并实现基于时间长度的睡眠等待和唤醒机制，在每个时钟中断发生时，操作系统产生对应的时间事件。应用程序或者操作系统的其他组件可以以此构建更复杂和高级的进程管理和调度。
sched.h,sched.c定义有关timer的各种相关接口来使用timer服务，其中主要包括:
1.typedef struct{....} timer_t:定义了timer_t的基本结构，其可以用sched.h中timer_init函数对其进行初始化。
2.void timer_init(timer t *timer,struct proc_struct *proc,int expires):对某定时器进行初始化，让它在expires时间片之后唤醒proc进程
3.void add_timer(timer t *timer):向系统添加某个初始化的timer_t，该定时器在指定时间后被激活，并将对应的进程唤醒至proc进程
4.void del_timer(timer t *timer):向系统删除或取消某一个定时器，该定时器在取消后不会被系统激活并唤醒进程
5.void run_timer_list(void):更新当前系统时间点，遍历当前所有处在系统管理内的定时器，找出所有应激活的计数器，并激活他们，该过程有且只有每次定时器中断时被调用,在ucore中，其还会调用调度器事件处理程序，
一个timer_t在系统中中的存活周期可以被描述如下:
1.timer_t在某个位置被创建和初始化，并通过add_timer加入系统
管理列表中
2.系统时间被不断累加，知道run_timer_list该timer_t到期
3.run_timer_list更改对应的进程状态，并从系统管理列表中移除该timer_t.

# 屏蔽与使能中断
根据操作系统原理的知识，我们知道如果没有在硬件级保证读内存-修改值-写入内存的原子性，我们只能通过复杂的软件来实现同步互斥操作。但由于有开关中断和test_and_set_bit等原子操作机器指令的存在，使得我们在实现同步互斥原语上可以大大简化。

























# 练习1
## 题目描述
理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题（不需要编码）
完成练习0后，建议大家比较一下（可用meld等文件diff比较软件）个人完成的lab6和练习0完成后的刚修改的lab7之间的区别，分析了解lab7采用信号量的执行过程。执行make grade，大部分测试用例应该通过。

请在实验报告中给出内核级信号量的设计描述，并说明其大致执行流程。

请在实验报告中给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同。

