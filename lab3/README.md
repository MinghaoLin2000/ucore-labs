前置知识
###一.
什么是虚拟内存?简单来说是指程序员或cpu看到的内存。但有几点注意
1. 虚拟内存不一定有实际的物理单元对应，实际的物理内存单元可能不存在
2. 如果虚拟内存单元对应有实际的物理内存单元，那二者的地址一般是不相等的。
3. 通过操作系统实现的某种内存映射可建立虚拟内存与物理内存的对应关系，使得程序员或cpu访问的虚拟内存地址会自动转换成一个物理内存地址。
那么这个虚拟的作用或意义在哪里体现呢? 在操作系统中,虚拟内存其实包含多个虚拟层次，在不同的层次体现不同的作用.首先，在有了分页机制后，程序员或cpu看到地址已经不是实际的物理地址了，这已经有一层虚拟化，我们可简称为内存地址虚拟化。有了内存地址虚拟化，我们就可以通过设置页表项来限定软件运行时的访问空间，确保软件运行不越界，完成内存访问保护的功能。

通过内存地址虚拟化，可以使得软件在没有访问某虚拟内存时，不分配具体的物理内存，只有在实际访问某虚拟内存地址时，操作系统再动态地分配物理内存，建立虚拟内存到物理内存的页映射关系，这种技术称为按需分页. 把不经常访问的数据所占的内存空间临时写道硬盘上，这样可以腾出更多的空闲内存空间给经常访问的数据，当cpu访问到不经常访问的数据时，再把这些数据从硬盘读入内存中，这种技术称为页换入换出。
##页面异常
当启动分页机制以后，如果一条指令或数据的虚拟地址所对应的物理页框不在内存中或者访问有错误(比如写一个只读页或用户态程序访问内核态)，就会发生页错误异常。产生页面异常的原因主要有:
1. 目标页面不存在(页表项全为零,即该线性地址与物理地址尚未建立映射或者已经撤销)
2. 相应的物理页面不在内存中（页表项非空,但present标志位=0，比如swap分区或者磁盘文件上）
3. 访问权限不符合(此时页表项p标志=1，比如企图写只读页面)
当出现上面情况之一，那么就会产生page fault异常。产生异常的线性地址存储在cr2中，并且将是page fault的产生类型保存在error code中。

##关键数据结构
page_fault函数不知道哪些是“合法”的虚拟页，原因是ucore还缺少有一定的数据结构来描述这种不在物理内存中的“合法”虚拟页。为此ucore还通过建立mm_struct和vma_struct数据结构，描述了ucore模拟应用程序运行所需的合法内存空间。当访问内存产生page fault异常时，可获得访问的内存方式（读或写）以及具体的虚拟内存地址，这样ucore就可以查询此地址，看是否属于vma_struct数据结构中描述的合法地址范围中，如果在，则可根据具体情况进行请求调页/页换入换出处理;如果不在,则报错。
![](https://chyyuu.gitbooks.io/ucore_os_docs/content/lab3_figs/image001.png)
##vma_struct
vma_struct描述应用程序对虚拟内存需求，以及针对vma_struct的函数操作。里把一个vma_struct结构的变量简称为vma变量。
```
struct vma_struct {  
        struct mm_struct *vm_mm;  //指向一个比vma_struct更高的抽象层次的数据结构mm_struct 
        uintptr_t vm_start;      //vma的开始地址
        uintptr_t vm_end;      // vma的结束地址
        uint32_t vm_flags;     // 虚拟内存空间的属性
        list_entry_t list_link;  //双向链表，按照从小到大的顺序把虚拟内存空间链接起来
    };  
```
VMA是描述应用程序对虚拟内存需求的变量。vm_start和vm_end描述的是一个合理地址空间范围（即严格确保vm_start< vm_end的关系）,list_link是一个双向的链表,按照从小到大顺序把一系列用vma_struct表示的虚拟内存空间链接起来，并且还要求这些链起来的vma_struct应该是不相交，即vma之间的地址空间无交集。
vm_flags表示了这个虚拟内存空间的属性，目前的属性包括
```
 #define VM_READ 0X00000001   //只读
 #define VM_WRITE 0x00000002 //可读写
 #define VM_EXEC  0x00000004 //可执行
```
vm_mm是一个指针,指向一个比vma_struct更高的抽象层次的数据结构##mm_struct
```
struct mm_struct {  
        list_entry_t mmap_list;  //双向链表头，链接了所有属于同一页目录表的虚拟内存空间
        struct vma_struct *mmap_cache;  //指向当前正在使用的虚拟内存空间
        pde_t *pgdir; //指向的就是 mm_struct数据结构所维护的页表
        int map_count; //记录mmap_list里面链接的vma_struct的个数
        void *sm_priv; //指向用来链接记录页访问情况的链表头
 };  
 ```
 mmap_list是双向链表头,链接了所有属于同一页目录表的虚拟内存空间,mmap_cache是指向当前正在使用的虚拟内存空间，由于操作系统执行的局部性原理，当前正在用到的虚拟空间在接下来的操作中可能还会用到,这时就不需要查链表，而是直接使用此指针就可找到下一次要用到的虚拟内存空间.pgdir所指向的就是mm_struct数据结构所维护的页表.通过访问pgdir可以查找某虚拟地址对应的页表项是否存在以及页表项的属性等. map_count记录mmap_List里面链接的vma_struct的个数.sm_priv指向用来链接记录页访问情况的链表头，这建立了mm_struct和后续要讲到的swap_manager之间的联系.
